#define _USE_MATH_DEFINES
#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
using namespace cv;

#include <armadillo>
using namespace arma;

#include <iostream>
#include <math.h> 
#include <ctime>
using namespace std;

/* 
a cpp implementation of matlab function fftshift
dim == 1 means row operation
dim == 2 means col operation
*/
cx_mat fftshift(cx_mat x,int dim){
	cx_mat res(size(x));
	if(dim==1){
		uword mid = x.n_rows/2;
		res.rows(0,mid-1) = x.rows(x.n_rows-mid,x.n_rows-1);
		res.rows(mid,x.n_rows-1) = x.rows(0,x.n_rows-mid-1);
	}
	else{
		uword mid = x.n_cols/2;
		res.cols(0,mid-1) = x.cols(x.n_cols-mid,x.n_cols-1);
		res.cols(mid,x.n_cols-1) = x.cols(0,x.n_cols-mid-1);
	}
	return res;
}

/*
a cpp implementation of matlab function ifftshift
dim == 1 means row operation
dim == 2 means col operation
*/
cx_mat ifftshift(cx_mat x,int dim){
	cx_mat res(size(x));
	if(dim==1){
		uword mid = x.n_rows/2;
		res.rows(0,x.n_rows-mid-1) = x.rows(mid,x.n_rows-1);
		res.rows(x.n_rows-mid,x.n_rows-1) = x.rows(0,mid-1);
	}
	else{
		uword mid = x.n_cols/2;
		res.cols(0,x.n_cols-mid-1) = x.cols(mid,x.n_cols-1);
		res.cols(x.n_cols-mid,x.n_cols-1) = x.cols(0,mid-1);
	}
	return res;
}

// convert 1*1 complex matrix to complex double
cx_double mat2cx_double(cx_mat x){
	cx_double res(x(0,0).real(),x(0,0).imag());
	return res;
}

// sinc function, both input and output are 1*N
mat sinc(mat x){
	mat res(size(x));
	for(uword i =0;i<x.n_elem;i++){
		if(x(0,i) == 0){
			res(0,i) = 1;
		}
		else{
			res(0,i) = sin(M_PI * x(0,i)) / (M_PI * x(0,i));
		}
	}
	return res;
}
// hamming window function, return a mat(1,L)
mat hamming(uword L){
	mat res(1,L);
	for(uword i=0;i<L;i++){
		res(0,i) = 0.53836 - 0.46164*cos(2*M_PI*i/(L-1));
	}
	return res;
}

// a cpp implementation of matlab function fix()
mat fix(mat x) {
	mat res=x;
	for (uword i =0;i<x.n_rows;i++){
		for(uword j=0;j<x.n_cols;j++){
			if(x(i,j) < 0){
				res(i,j) = floor(x(i,j));
			}
			else{
				res(i,j) = ceil(x(i,j));
			}
		}
	}
	return res;
}

// turn kx vector into matrix of the same col dim and row dim of Nf
mat vec2mat_y(vec kx, uword Nf){
	mat kx_mat(kx.n_elem,Nf);
	for(uword i=0;i<kx.n_elem;i++){
		for(uword j=0;j<Nf;j++){
			kx_mat(i,j) = kx(i);
		}
	}
	return kx_mat;
}

// turn ky vector into matrix of the same row dim and col dim of Nf
mat vec2mat_x(vec ky, uword Nf){
	mat kx_mat(Nf,ky.n_elem);
	for(uword i=0;i<Nf;i++){
		for(uword j=0;j<ky.n_elem;j++){
			kx_mat(i,j) = ky(j);
		}
	}
	return kx_mat;
}

cx_vec vec2cx_vec(vec a, double imaginary_part) {
	cx_vec res(a.n_elem);
	uword i=0;
	while(i<a.n_elem){
		res(i) = cx_double(a(i),imaginary_part);
		i++;
	}
	return res;
}

int main() {

	// time start
	time_t tstart, tend; 
	tstart = time(0);

	// import echo data
	mat S_echo_real;
	S_echo_real.load("real2d.txt",arma_ascii);
	mat S_echo_imag;
	S_echo_imag.load("imag2d.txt",arma_ascii);

	cx_mat S_echo(S_echo_real,S_echo_imag);

	double system_delay = 2.069;

	// Nx = 129
	double Nx = S_echo.n_rows;

	// Nf = 201	
	double Nf = S_echo.n_cols;
	double R0 = 5 ;
	double dx = 0.01;
	double c = 299792458;
	double f_start = 28000000000;
	double f_stop = 33000000000;
	
	vec freq = linspace<vec>(f_start,f_stop,Nf);
	vec k = 2 * M_PI * freq/c;

	// repmat(reshape(freq,[1,Nf]),[Nx,1])
	mat freq_mat = vec2mat_x(freq,Nx);
	cout<<freq_mat.n_rows<<" "<<freq_mat.n_cols<<endl;

	cx_mat delay(cos(2*M_PI*freq_mat*2*system_delay/c),sin(2*M_PI*freq_mat*2*system_delay/c));
	cout<<delay.n_rows<<" "<<delay.n_cols<<endl;
	S_echo = S_echo % delay;
	S_echo = fftshift(S_echo,2);

	double deltkr=k(1)-k(0);
	double deltkz = 2 * deltkr; 

	double Theta_antenna = 45*M_PI/180;

	// S_echo 51*200
	cout<<"S_echo dim "<<S_echo.n_rows<<" * "<<S_echo.n_cols<<endl;
	S_echo = S_echo.t();
	double FFT_NUM_Multi_x = 2;
	double FFT_NUM_Multi_z = 2;

	double NLx = 2;
	double NLz = 2;

	double FNx = Nx; 
	double FNf = Nf;

	vec kx = linspace(-M_PI/dx, M_PI/dx - 2*M_PI/dx/FNx, FNx);
	double deltkx = kx(1)-kx(0);

	// match filter
	// KX is copied from kx alone y-axis for Nf times
	// KX:51*200
	mat KX = vec2mat_x(kx,Nf);	
	cx_mat matched_filter(size(S_echo));

	// KZ is copied from k alone x-axis for FNx times. Note k is a vec on the y-axis.
	// KZ:51*200
	mat Kr = vec2mat_y(k,FNx);

	/*
	mat KZ = 4 * Kr; 
	KZ = sqrt(pow(KZ,2)-pow(KX,2));
	cout<<"Kr dim "<<Kr.n_rows<<" * "<<Kr.n_cols<<endl;
	
	// Matched_filter = exp(1i*KZ*R0).* (abs(KX) <= 2*(k*ones(1,FNx)));
	for(uword i=0;i<KZ.n_rows;i++){
		for(uword j=0;j<KZ.n_cols;j++){
			if(abs(KX(i,j))<=2*KZ(i,j)) {
				matched_filter(i,j).real(cos(R0*KZ(i,j)));
				matched_filter(i,j).imag(sin(R0*KZ(i,j)));
			}
			else{
				matched_filter(i,j).real(0.0);
				matched_filter(i,j).imag(0.0);
			}
		}
	}
	*/
	Kr = 2 * Kr;
	mat Kz_sq = pow(Kr,2) - pow(KX, 2);

	
	// S_kx is generated by fft S_echo on each col 51*200
	S_echo = fftshift(S_echo,2);
	cx_mat S_kx = fft(S_echo.t()).t();
	S_kx = fftshift(S_kx,2);

	cout<<"S_kx dim "<<S_kx.n_rows<<" * "<<S_kx.n_cols<<endl;

	
	for(uword i=0;i<Kz_sq.n_rows;i++){
		for(uword j=0;j<Kz_sq.n_cols;j++){
			if(Kz_sq(i,j)<0){
				Kz_sq(i,j)=0;
				S_kx(i,j).real(0.0);
				S_kx(i,j).imag(0.0);
			}
		}
	}

	mat fmf = R0 * sqrt(Kz_sq);
	cx_mat after_exp_fmf(cos(fmf),sin(fmf));
	cx_mat S_matched = S_kx % after_exp_fmf;
	

	// matlab angle function
	// mat S_matched_angle = atan(S_matched.imag() / S_matched.real());

	uword line_num = S_matched.n_rows;
	uword col_num = S_matched.n_cols;

	cout<<"n_rows:"<<line_num<<" n_cols:"<<col_num<<endl;
	double mid_line= round(line_num/2); 

	// stolt interpolation
	double P = 4;
	mat Kz_inter = Kr;
	mat identity = k(0) * ones<mat>(KX.n_rows, KX.n_cols);
	mat DKZ = 0.5*sqrt(pow(KX,2) + pow(Kz_inter,2)) - identity;

	mat NDKY = fix(DKZ/deltkr);
	cout<<"NDKY dim "<<NDKY.n_rows<<" * "<<NDKY.n_cols<<endl;
	double Nd = NDKY.max();
	// B1=[S_matched;zeros(Nd+P,FNx)];
	cx_mat B1(Nf+Nd+P, FNx);
	for(uword i=0;i<Nf+Nd+P;i++){
		for(uword j=0;j<FNx;j++){
			if(i<Nf){
				B1(i,j) = S_matched(i,j);
			}
			else{
				B1(i,j).real(0.0);
				B1(i,j).imag(0.0);
			}
		}
	}
	
	// win_interp = hamming(2*P).';
	mat win_interp = hamming(2*P);
	mat NN(1,2*P);
	mat be4sinc(size(NN));
	cx_mat part_of_B1(size(NN));
	cx_mat Stolt(Nf,FNx,fill::zeros);
	for(uword i=P;i<Nf;i++) {
		NN.zeros();
		be4sinc.zeros();
		part_of_B1.zeros();
		for(uword j=0;j<FNx;j++){
			// NN = NDKY(i,j) + (-P+1:P); 
			for(uword k=0;k<NN.n_elem;k++){
				NN(0,k) = NDKY(i,j) + (-1*P)+k+1;
				be4sinc(0,k) = DKZ(i,j)/deltkr - NN(0,k);
				part_of_B1(0,k) = B1(1+NN(0,k),j);
			}
			// Stolt(i,j)=(win_interp .* sinc( DKZ(i,j)/deltkr - NN )*B1( 1 + NN,j));
			mat be4stolt_real = win_interp % sinc(be4sinc);
			mat be4stolt_imag(size(be4stolt_real), fill::zeros);
			cx_mat be4stolt(be4stolt_real,be4stolt_imag);
			Stolt(i,j) = mat2cx_double(part_of_B1 * ((be4stolt).t()));
		}
	}

	double kx_max = 2*k(0)*tan(Theta_antenna/2);
	double kz_min = 2*k(P-1);
	double kz_max = sqrt(4 * pow(k(k.n_elem-1),2) - pow(kx_max,2));

	/*
	// Stolt = Stolt.*((abs(Kx)<=kx_max).*(KZ_interp <= kz_max).*(KZ_interp >= kz_min));
	for(uword i=0;i<Nf;i++) {
		for(uword j=0;j<FNx;j++){
			if(!((abs(KX(i,j)) <= kx_max) && (Kz_inter(i,j) <= kz_max) && (Kz_inter(i,j) >= kz_min))) {
				Stolt(i,j).real(0.0);
				Stolt(i,j).imag(0.0);
			}
		}
	}
	cout<<"Stolt_azimuth dim "<<Stolt.n_rows<<" * "<<Stolt.n_cols<<endl;
	double NWa = 2*floor(kx_max/deltkx);
	cout<<"NWa: "<<NWa<<endl;
	// Win_f( P : round((kz_max-kz_min)/deltkz),:) = (hamming(round((kz_max-kz_min)/deltkz)-P+1))*ones(1,FNx);
	mat Win_f(Nf,FNx,fill::zeros);
	double rnd_kz = round((kz_max - kz_min)/deltkz);
	Win_f.rows(P,rnd_kz) = hamming(rnd_kz -P +1).t() * ones(1,FNx);
	cout<<"Win_f dim "<<Win_f.n_rows<<" * "<<Win_f.n_cols<<endl;
	// Win_azimuth(:,FNx/2 - NWa/2 + 1:FNx/2 + NWa/2) = ones(Nf,1)*(hamming(NWa)).';
	mat Win_azimuth(Nf,FNx,fill::zeros);
	cout<<FNx/2 - NWa/2 + 1<<" "<<FNx/2 + NWa/2<<endl;
	Win_azimuth.cols(FNx/2 - NWa/2 + 1, FNx/2 + NWa/2) = ones(Nf,1) * hamming(NWa);
	cout<<"Win_azimuth dim "<<Win_azimuth.n_rows<<" * "<<Win_azimuth.n_cols<<endl;
	// Stolt=Stolt.*Win_azimuth;
	Stolt = Stolt % Win_azimuth;
	// Stolt=Stolt.*Win_f;
	Stolt = Stolt % Win_f;

	*/
	// image_r_x = ifft(Stolt,FNf*NLz,1); 51*8
	cx_mat image_r_x = ifft(Stolt,FNf*NLz);
                                                                      
    // image_r_x = ifft(image_r_x,FNx*NLx,2); 200*8
    image_r_x = ifft(image_r_x.t(),FNx*NLx).t();

    // image_r_x=ifftshift(image_r_x,1);                           
    // image_r_x=ifftshift(image_r_x,2); 
    image_r_x = ifftshift(image_r_x,1);
    image_r_x = ifftshift(image_r_x,2);
    cout<<"image_r_x dim "<<image_r_x.n_rows<<" * "<<image_r_x.n_cols<<endl;                                                          

    mat image_r_x_mat = abs(image_r_x);
    image_r_x_mat = image_r_x_mat / image_r_x_mat.max();
    cout<<"image_r_x_mat dim "<<image_r_x_mat.n_rows<<" * "<<image_r_x_mat.n_cols<<endl; 

    image_r_x_mat = 20*log10(image_r_x_mat);
    
    // opencv plot
    /*
    double img_bg = image_r_x_mat.max() - dynamic_range;

    for(uword i=0;i<image_r_x_mat.n_rows;i++){
    	for(uword j=0;j<image_r_x_mat.n_cols;j++){
    		if(image_r_x_mat(i,j) < img_bg){
    			image_r_x_mat(i,j) = img_bg;
    		}
    	}
    	cout<<i<<endl;
    }
    cout<<"eof"<<endl;

    cv::Mat img0( image_r_x_mat.n_rows, image_r_x_mat.n_cols, CV_8UC1, image_r_x_mat.memptr());
	cv::Mat image;
	applyColorMap(img0, image, COLORMAP_HOT);
	namedWindow( "Display window", WINDOW_NORMAL);
	imshow("Display window", image);
	waitKey(0);

	*/

	// make the background dark
	double dynamic_range = 50; 
    double img_bg = image_r_x_mat.max() - dynamic_range;

    for(uword i=0;i<image_r_x_mat.n_rows;i++){
    	for(uword j=0;j<image_r_x_mat.n_cols;j++){
    		if(image_r_x_mat(i,j) < img_bg){
    			image_r_x_mat(i,j) = img_bg;
    		}
    	}
    	cout<<i<<endl;
    }
    cout<<"eof"<<endl;
    image_r_x_mat.save("image_r_x_mat.txt",arma_ascii);

    // time end
    tend = time(0); 
    cout << "It took "<< difftime(tend, tstart) <<" second(s)."<< endl;

	return 0;
	
}