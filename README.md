# cpp implementation of near-field SAR
A cpp implementation of near-field SAR. The original code is written in MATLAB.

## How to setup

Using armadillo to do matrix/cube transformation and opencv to plot.

Armadillo can be downloaded here http://arma.sourceforge.net/download.html.

OpenCV can be downloaded from https://github.com/opencv/opencv. This is the most recent update.

An installation guide can be found here: http://stackoverflow.com/questions/19671827/opencv-installation-on-mac-os-x.


## The files

1. Azimuth.cpp 

Azimuth.cpp creates a simulated target that consists of 5 dots and processes the points into received signal (S_echo in the .cpp file). The received signal is then computed to retrieve the target. This .cpp file aims to test and give a simple demo of the retrieving algorithm.

2. Generalized_azimuth.cpp

This is the main program that retrieve real received 2D signal.


## How to play with Azimuth.cpp

1. ‘g++ azimuth.cpp -o azimuth -O2 -larmadillo’ and run ‘./azimuth’ to save the image data into ‘image_r_x_mat.txt’. 

2. Delete the header of ‘image_r_x_mat.txt’ that was generated by the armadillo save function (you can refer to the armadillo docs for detail).

3. ‘python plotdata.py’ to see the resulting image which has 5 bright dots.


## How to play with Generalized_azimuth.cpp

1. (If you have custom received signal) use Matlab to get the dimensions of the input data. Then add ‘ARMA_MAT_TXT_FN008 num_row num_col’ , as shown in ‘real2d.txt’ and ‘imag2d.txt’

2. ‘g++ generalized_azimuth.cpp -o generalized_azimuth -O2 -larmadillo’ and run ‘./generalized_azimuth’ to save the image data into ‘image_r_x_mat.txt’.

3. Delete the header of ‘image_r_x_mat.txt’ that was generated by the armadillo save function (you can refer to the armadillo docs for detail).

4. ‘python plotdata.py’ to see the resulting target image.


## How to compile if you are using opencv:

‘g++ azimuth.cpp \`pkg-config --libs --cflags opencv\` -o example1 -O2 -larmadillo’

You'll need to install pkg-config before compiling
