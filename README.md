# cpp implementation of near-field SAR
A cpp implementation of near-field SAR. The original code is written in MATLAB.

## How to setup

Using armadillo to do matrix/cube transformation and opencv to plot.

Armadillo can be downloaded here http://arma.sourceforge.net/download.html.

OpenCV can be downloaded from https://github.com/opencv/opencv. This is the most recent update.

An installation guide can be found here: http://stackoverflow.com/questions/19671827/opencv-installation-on-mac-os-x.


## The files

### azimuth.cpp
Azimuth.cpp creates a simulated target that consists of 5 spots and processes the target into received signal (S_echo in the .cpp file). The received signal is then computed to reconstruct the target. This .cpp file aims to test and give a simple demo of the construction algorithm.

### generalized_azimuth.cpp 
This is the main program that reconstruct real 2D signal. The signal is stored in 'real2d.txt' and 'imag2d.txt'.

### plotdata.py 
A plotting tool in python as an alternative to opencv. It loads data from 'resulting_image.txt'.

### WK_3D_imaging_experiment.cpp
The main program using WK algorithm to reconstruct 3D signal. The received signal is stored separately in 'secho_real.txt' and 'secho_imag.txt".


## How to play with Azimuth.cpp

1. `g++ azimuth.cpp -o azimuth -O2 -larmadillo` and run `./azimuth` to save the image data into ‘resulting_image.txt’. 

2. Delete the header of ‘resulting_image.txt’ that was generated by the armadillo save function (you can refer to the armadillo docs for detail).

3. ‘python plotdata.py’ to see the resulting image which has 5 bright dots.


## How to play with Generalized_azimuth.cpp

1. (If you have custom received signal) use Matlab to get the dimensions of the input data. Then add ‘ARMA_MAT_TXT_FN008 num_row num_col’, as shown in ‘real2d.txt’ and ‘imag2d.txt’

2. `g++ generalized_azimuth.cpp -o generalized_azimuth -O2 -larmadillo` and run `./generalized_azimuth` to save the image data into ‘resulting_image.txt’.

3. Delete the header of ‘resulting_image.txt’ that was generated by the armadillo save function (you can refer to the armadillo docs for detail).

4. `python plotdata.py` to see the resulting image.


## How to play with WK_3D_imaging_experiment.cpp

1. (If you have custom received signal) use Matlab to get the dimensions of the input data. Then add ‘ARMA_CUB_TXT_FN008 num_rows num_cols num_slices’, as shown in ‘secho_real.txt’ and ‘secho_imag.txt’

2. `g++ WK_3D_imaging_experiment.cpp -o WK_3D_imaging_experiment -O2 -larmadillo` and run `./WK_3D_imaging_experiment` to save reconstructed imaging data into ‘resulting_image.txt’.

3. Delete the header of ‘resulting_image.txt’ that was generated by the armadillo save function (you can refer to the armadillo docs for detail: http://arma.sourceforge.net/docs.html#save_load_mat).

4. `python plotdata.py` to see the resulting image.


## How to compile if you are using opencv:

`g++ azimuth.cpp 'pkg-config --libs --cflags opencv' -o example1 -O2 -larmadillo`

You'll need to install pkg-config before compiling

